CQL Syntax
Preamble
　このドキュメントはCassandra Query Language（CQL）のv3について書かれたものだ。CQL v3はCQL v2への後方互換を持っておらず、多くの点で異なっている。このドキュメントは最新のバージョンについて書かれている。changesセクションにおいて各バージョンでの変更点を記している。
　
　CQL v3では感覚的に、モデルがSQLにとても近いものになっている。データはテーブルにある行の列として保存されるといったことなど。よって、このドキュメントでは、テーブル、行、列のような用語はSQLでのそれらと同様の意味を持つ。だけど覚えておいてほしい。それらはCassandraの実装やthrift、CQL v2のAPIで見られた行や列のコンセプトとは別のものだ。
　
Conventions
CQLシンタックスを表現するため、このドキュメント中では表記に下記のルールを設ける。
・ルールとしてバッカス（・ナウア）記法を使う。
<start> ::= TERMINAL <non-terminal1> <non-terminal1>
・非終端の記号は<angle brackets>を用いる
・さらにバッカス記法の省略形として正規表現の標準的な記号?,+,*を任意、and、orの意味で使う。丸括弧は記号のグループ化に使い、[<characters>]と記したときは<characters>に含まれるいずれか一つのキャラクターを表現しているとする
・文法はドキュメント化のために使われるが、それでもマイナーな詳細をいくつか残している。たとえばCREATE TABLEステートメントでの最後の列定義はオプションであるがサポートされており、もしこのドキュメントで提供されている文法だとしてもおすすめはしていない。
・サンプルコードはコードブロックによって示される

・文中でのキーワード参照やCQLコードは固定幅フォントで記す。 ## この訳ではやっていない

Identifiers and keywords
CQLはテーブルや列を識別するのに識別子（名前）を使う。識別子は正規表現[a-zA-Z0-9_]*にマッチする。## つまりこれ以外の文字を使うなってこと？
SELECTやWITHのような識別子はキーワードとする。それらは意味を与えられており、予約されている。キーワードのリストは付録Aで。
識別子や引用符で囲まれいないキーワードは大文字小文字の区別がない。SELECTはselectやｓElEcTと同じ、myIdはmyidやMYIDと同じである。慣例としてはキーワードには大文字が使われ、他の識別子には小文字が使われる。
識別子には引用識別子というものがある。これはダブルクオート(")で囲まれた文字列を指す。引用識別子はキーワードとしては使われない。囲われた文字列は大文字、小文字の違いが区別される。"My Id"と"my id"は違うものだ。すべて小文字の引用識別子は二重引用符を外せば、同じ文字で構成されたただの識別子と同じ意味となる（"myid"はmyidとmyIdと同じ、"myId"とは違う）。引用識別子の中で二重引用符を使いたければ、二重引用符を二回打つことでエスケープされる（"foo""bar"）。


Constants
CQLは次の定数を取ることができる: strings, integers, floats, booleans, uuids, blobs
・文字列は引用符（'）で囲うことで表す。文字列中で引用符を使いたければ二回打てばエスケープされて使える。'It''s raining today'。二重引用符を使って引用識別子と文字列を混同することがないように。
・intは以下のように表される'-'?[0-9]+（要は123とか-30とか）
・floatは以下のように。'-'?[0-9]+('.'[0-9]*)?([eE][+-]?[0-9+])?。NanやInfinityも扱いはfloatとなる。
・booleanはtrueとfalseだが、大文字小文字の使い方で区別されることはない。
・UUIDは以下のように。hex{8}-hex{4}-hex{4}-hex{4}-hex{12}。
・blobは0[xX](hex)+の繰り返して表される。
これらの定数が実際にどういう形を取るかはdata types sectionを参考に。

Comments
CQL中においてコメントは--か//で行を始める。複数行にわたるコメントは/*と*/で囲うこと。

Statements
CQLはステートメントから成る。SQLと同様にこのステートメントは三つのカテゴリに分けられる。
・ストアされているデータをセットしたり変えるためのデータ定義ステートメント
・データを変更するためのデータ操作ステートメント
・データを探すためのクエリ
すべての文はセミコロン(;)で終わる。ただし単一のステートメントを扱う場合は省くことができる。サポートしているステートメントは以下のセクションで示す。上記のステートメントの文法を記すのに、以下のような非終端の記号を用いる。


注意として、実際にすべてのケースで上記の文法が有効なわけではない。とくに、<variable>と入れ子にされた<collection-literal>は<collection-literal>のなかで有効ではない。

<variable>は匿名にもなれば名前を持つこともできる。どちらも準備ステートメントで変数と結び付けられる。匿名と命名済みの変数の違いは参照が楽になるかどうかだけである。

<properties>はキースペースやテーブルを作ったり変更するのに使う。それぞれの<property>は単一の値かマッピングされた値を取る。詳しくはのちに触れる。

<tablename>はテーブルの特定に使う。キースペースが指定されていない状態では、<tablename>はアクティブなキースペースの該当テーブルを指す（キースペースの指定はUSEを使う）。

サポートされている<function>はfunctionsセクションを参照すること。

Prepared Statement
CQLは準備ステートメントをサポートしている。準備ステートメントはクエリを一度展開し、複数回違った値でそのクエリを実行するときに使う。

ステートメントにおいて列の値が求められているなら、<variable>を使うことができる。その場合は変数を結びつけられたステートメントが必要となる。それが用意できれば、それに実際の値を与えることでそれを実行できる。これを使う実際の手続きはCQLドライバに依存しているもので、このドキュメントでこれ以降には載せていない。


Data Definition
CREATE KEYSPACE
CREATE KEYSPACEステートメントは新しくトップレベルのキースペースを作る。キースペースはレプリケーションの方式とテーブルセットのオプションを規定する一つのネームスペースである。キースペースの名前として使えるのは32文字以下の英数字である。識別子としてのキースペース名は大文字小文字の区別をしないので、そうしたければ引用識別子を使うこと。
CREATE KEYSPACEステートメントが<properties>としてサポートするのは以下である。

replication <peroperty>は必須である。少なくともclassサブオプションまで指定しなければならない。ほかのサブオプションはclassに従うようになっている。デフォルトではCassandraは以下のclassをサポートしている。
・'SimpleStrategy':クラスタを丸々使ってシンプルなレプリケーションを定義する。サブオプションとして'replication_factor'をサポートしており、これは必須である。。
・'NetworkTopologyStrategy':それぞれのデータセンタで独立したレプリケーションファクタを置くやり方である。他のオプションはキーバリューペアであり、キーはデータセンタの名前を、バリューはレプリケーションファクタを指す。
・'OldNetworkTopologyStrategy':古いレプリケーション方式である。これよりNetworkTopologyStrategyを使った方がいい。
既存のキースペース名で新たにキースペースを作ろうとすると、エラーが返される。IF NOT EXISTSを使ってそれをやると、ステートメントは結局なにもしないことになる。

USE
USEステートメントは既存のキースペース名と使うことで、現在の使用キースペースを変更する。

ALTER KEYSPACE
ALTER KEYSPACEステートメントは既存のキースペースのプロパティを変更する。サポートされる<properties>はCREATE TABLEと同じである。

DROP KEYSPACE
DROP KEYSPACEステートメントはキースペースとそこに含まれるデータをただちに削除する。
キースペースが存在していなければステートメントはエラーを返す。

CREATE TABLE
CREATE TABLEステートメントは新しくテーブルを作る。それぞれのテーブルは行の集合である。CREATE COLUMNTABLEシンタックスはCREATE TABLEのエイリアスとしてサポートされている（これまでの開発の経緯からの理由で）。

IF NOT EXISTSを使わずに既存のテーブルと同じ名前でテーブルを作ろうとするとエラーが返される。使った場合で、すでに同名のテーブルが存在するなら、そのステートメントはなにもしない。

<tablename>
テーブルの名前として使えるのはキースペースと同じ条件である（32文字以内で英数字）。もしテーブルの名前だけで宣言されたなら、それは現在のキースペース内で作られる。既存のキースペースと共に宣言されればそのキースペースに作られる。

<column-definition>
CREATE TABLEステートメントはテーブルに入る行の列を定義する。列はその名前と型で宣言する。

テーブル内において、行は固有のPRIMARY KEYで識別される。そして行の定義時にはPRIMARY KEYも定義することが必須である。PRIMARY KEYとしてテーブル内の複数の列を指定することもできる。もしPRIMARY KEYが一つの列ならば、列定義の際に後ろにPRIMARY KEYを付ければいい。複数の列を使うなら、コンマ区切りのリストで定義する必要がある。

Partition key and clustering columns
CQLでは列がPRIMARY KEYの並び順を決める。最初の列のキーをパーティションキーと呼ぶ。パーティションキーにはすべての行で同じパーティションキーを（テーブルさえまたがって）同じ物理ノードでは共有するという特徴がある。与えられたテーブルでの同一のパーティションキーを共有する行への挿入、更新、消去は分離されアトミックに行われる。パーティションキーは丸括弧を使うことで、複数の列から作ることもできる。

STATIC columns
いくつかの列はテーブル定義時STATICとして宣言できる。静的な列は同じパーティションにある持つ行の間で共有される（SELECTを参照すること）。

最後のクエリはsの値としてstatic1を返す。なぜならsは静的で共有されている値であり、ここに書き込まれた最新の値はstatic1だからである。もしこの例での二つの行が異なるパーティションにあるなら（たとえばpkの値が異なるとき）、二度目のsへの書き込みによって最初の行のデータが代わるようなことはない。

静的な列に関していくつか制約がある。
・COMPACT STORAGEオプションを適用したテーブルは静的な列を使えない
・クラスタリングされたカラムのないテーブルは静的な列を使えない。
・PRIMARY KEYでない列だけが静的にできる

<option>
CREATE TABLEステートメントは新しいテーブルを作成する際のいくつものオプションをサポートしている。これはWITHキーワードとともに使う。

オプションの中で最初にあるのはCOMPACT STORAGEである。CQL3以前のものとの互換を目的としたものである（詳細はwww.datastax.com/dev/blog/thrift-to-cql3）。これはディスクに保存されるデータのレイアウトをコンパクトにするものだが、テーブルの柔軟性や拡張性を落とす。COMPACT STORAGEのテーブルはコレクションや静的な列を持てず、少なくともクラスタリングされた列を一つだけ（0でも2以上でもなく）PRIMARY KEY以外でサポートしている。以上の理由から古いものを後方互換で動かす以外では使用が推奨されていない。

CLUSTERING OF|RDERというオプションがある。これはディスク上に保存される行データのオーダーに関わってくる。クラスタリングされた列の名前リストとともに使い、それらのオーダーをどうするかを決める（ascかdescか）。このオプションはSELECTのORDER BYが返す結果に影響を与える。

テーブル作成において<property>でサポートされるのは以下がある。


compaction options
compactionプロパティは少なくともclassサブオプションを定義しなければならない。classサブオプションはコンパクションストラテジクラスを使うかを決定する。デフォルトでサポートされるのはSizeTieredCompactionStrategyとLeveledCompactionStrategyである。カスタムストラテジはstring constantによるクラス名で用意される。残りのサブオプションは選んだクラスによって変わる。残りのサブオプションは以下である。


Other considerations:
すでに定義されている行にデータを入れたい場合、すべての列が必要になるわけではない（キーの一部になっているものは必要）。値を持たない列はディスク上にスペースを取らない。さらに、新しい列を加えるには、一定時間しか要さない。テーブルを作っているときに将来の使用量予想を試みる必要はないだろう。

ALTER TABLE
ALTER TABLEステートメントはテーブル定義を操作するために使う。新しい列を加える、既存の列を消す、列の型を変える、あるいはテーブルオプションを新しくするなど。テーブル作成と同様、ALTER COLUNFAMILYはALTER TABLEのエイリアスである。

<tablename>はキースペース名に先行するオプションである。<instruction>はどういう変更を施すかを定義する。
ALTER:既に定義された列の型を新しくする。clustering columnsの型は変更できない。secondary indexが作成されている列も同じ制限がある。他の列に関しては制限はないが、互換性のない型への変換は悪い案である。CQLドライバが混乱する原因となる。
ADD:テーブルへ新しく列を追加する。新しい列の<identifier>はすでにある列と混乱するものであってはならない。さらにCOMPACT STORAGEオプションが選択されたテーブルには列を加えられない。
DROP:テーブルから列を消去する。消去された列はただちにクエリで使えなくなる。もし列が読み込まれれば、クエリは消去される直前の値を返すわけではない。タイムスタンプは正確な時刻を表すので、消去された列を読むべきではない。COMPACT STORAGEオプションが選択されたテーブルでは列を消去することはできない。
WITH:テーブルのオプションを変更する。サポートされているオプションはCREATE TABLEと同じだが、COMPACT STORAGEはサポートされていない。あらゆるcompactionサブオプションは、すでに設定されていたcompactionオプションを上書きする。だから残したい設定があるなら、新たな設定をする前に、すでにされた設定を調べておかなければならない。compressionオプションについても同じである。

DROP TABLE
DROP TABLEステートメントは即座にテーブルをテーブル内のデータとともに消去し、結果を巻き戻すことはできない。テーブル作成と同様にDROP COLUMNFAMILYはDROP TABLEのエイリアスである。

IF EXISTSを使わずに存在しないテーブルを消去しようとするとエラーを返す。

TRUNCATE
TRUNCATEステートメントはテーブルからすべてのデータを消す。

CREATE INDEX
CREATE INDEXステートメントはセカンダリインデックスを作るのにつかわれる。インデックスを作るカラムの名前の前にONを使う。もしデータがすでにあるならば、非同期でインデックス化が行われる。インデックスが作られたあとで、新しいデータが列に入れられると、データ挿入と共に自動でインデックスに入れられる。

すでにインデックスが存在しているのにこのステートメントを使うとエラーを返す。このエラーはIF NOT EXISTSを使えば回避される。

DROP INDEX
DROP INDEXステートメントはすでにあるセカンダリインデックスを消去するために使う。引数として消したいインデックスの名前を使う。IF EXISTSを使わずに存在しないインデックスを消去しようとするとエラーを返す。


Data Manipulation
INSERT
INSERTステートメントは与えられた行への新しい列データの挿入を行う。行はPRIMARY KEYで特定されるもので、列は少なくともPRIMARY KEYを構成できるデータが必要になる。

SQLとの違いとして、INSERTは行の存在チェックを行わず、あるならアップデート、なければ新しく作成される。データの作成が行われたかアップデートが行われたかを突き止める価値はない。

挿入のみを行うためにIF NOT EXISTSを使うこともできる。しかしIF NOT EXISTSを使うと無視できないほどのパフォーマンスコストを支払うことになるので、使用は慎重に行いたい。

挿入によるすべてのアップデート処理はアトミックに独立して行われる。

UPDATEセクションを参照し、<option>で使用できるものの情報を得て、collectionsセクションで<collection-literal>の使い方も参照してほしい。またINSERTは、UPDATEのようなカウンターをサポートしていない。

UPDATE
UPDATEステートメントは指定された行データに任意の数の列を書き込む。<where-clause>は更新する行を絞るために使い、PRIMARY KEYを含んだものでなければならない（INリレーションはパーティションキーの最後の列に対してのみサポートされている）。他の列の値はSETk-ワードの後の<assignment>によって指定される。

SQLとの違いとして、UPDATEは行の存在チェックを行わず、あるならアップデート、なければ新しく作成される。データの作成が行われたかアップデートが行われたかを突き止める価値はない。

更新のみを行うためにIFを使うこともできる。しかしIFを使うと無視できないほどのパフォーマンスコストを支払うことになるので、使用は慎重に行いたい。

挿入によるすべてのアップデート処理はアトミックに独立して行われる。

<assignment>におけるc=c+3という式はカウンタの更新を行う。'='のあとの前後の識別子は必須である（カウンタについてはインクリメント、デクリメントのみが可能で、値を適用することはできない）。

<option>
UPDATEとINSERTは挿入において以下に従う。
・TIMESTAMP:処理のためにタイムスタンプをセットする。とくに記述しなければ現在の時刻（マイクロ秒で）が使われる。
・TTL:挿入される値に関してTime To Liveを与える。もしセットされれば、その指定時刻経過後に挿入されたデータが消去される。TTLは列自身に与えられるものではない。これが意味するのは、それ以降のいかなる処理も列を更新し、TTLをリセットするということである（TTLは行われた更新に記述された、新たなTTLの値に従う）。デフォルトでは値は消去されない。TTLの値としての0以下の数値はTTLをセットしないことと同義である。

DELETE
DELETEステートメントは列と行を消去する。もし列の名前がDELETEの直後にあれば、その列だけが行から消される。<where-clause>で消去するデータを選択できる（<selection>でのid[value]シンタクスはコレクションに使われる。詳しくはcollectionセクションを参照）。でなければ全ての行が消去される。<where-clause>は消去する行のキーを指定する（INリレーションはパーティションキーの最後の列に対してのみサポートされている）。

DELETEはUPDATEと同様にTIMESTAMPオプションをサポートする。

DELETEステートメントにおいて、同じパーティションキーが使われているところで行われるすべての消去は分離されアトミックに行われる。

BATCH
BATCHステートメントは複数の操作（挿入、更新、消去）を一つのステートメントにまとめる。これの主な目的は二つある。
１．クライアントとサーバ（あるいは調整サーバとレプリカ）のネットワーク間でのやり取りを抑える。
２．BATCHの与えられたパーティションキーによるすべての更新は分離しアトミックに動作する。
BATCHステートメントはUPDATE、INSERT、DELETEのみをサポートし、SQLトランザクションすべてをサポートするわけではない。
<option>
BATCHはTIMESTAMPオプションを、UPDATEステートメントと似たセマンティックでサポートする（タイムスタンプはバッチ内のステートメントによって適用される）。だがバッチ内のステートメントでTIMESTAMPを使ってはならない。

Queries
SELECT
SELECTステートメントはテーブルの中の任意の数の行から、任意の数の列を読み込む。行のセットを返し、それらはクエリに対応した列のまとまりを持っている。

<select-clause>
<select-clause>は必要な列を指定し、その結果のセットを返す。コンマ区切りで指定するか、ワイルドカード(*)を使う。

<selector>は取り出す列の名前か、任意の数の列の名前の<function>である。ファンクションについては<term>と同様で、functionセクションで記述する。加えてこれらの一般的なファンクションはWRITETIMEファンクションは列が挿入されたときに作られたタイムスタンプに従う。

いかなる<selector>もASキーワードを使うことでエイリアスとなる（サンプル参照）。<where-clause>と<order-by>で列を参照するときはオリジナルの名前で参照するべきで、エイリアスによって参照するべきではない。

COUNTキーワードは*を丸括弧でおおって使う。使った場合、クエリはマッチした行の数のみを返す。COUNT(1)はエイリアスとしてサポートされている。

<where-clause>
<where-clause>にはクエリにかかる行を指定しなければならない。パーティションキーにおいて等価でない関係（INが単一の等価関係として使われた場合）はサポートされていない（だがパーティションキーにおいて非等価な関係のクエリを行うTOKENメソッドについて下で記している）。さらに、与えられたパーティションキーによってクラスタリングされた列は、行のオーダリングを行い、隣り合った行セットの選択のみが行われる。

以下のクエリは問題ない。

以下のクエリは隣り合った行のセットが選択されておらず、クエリとして実行できない。

関係について詳しく述べると、TOKENファンクションはPARTITION KEYの列をクエリするのにつかわれる。その場合、行はその値でなくPARTITIONKEYのトークンで選択される。キーのトークンは使用するパーティションに依存しており、ランダムパーティションは意味のある順序付けを行わない。パーティションの順序付けは常にバイトごとのトークン値の順序付けを行う（たとえパーティションキーの型がintだとして、特にtoken(-1) > token(0)でも）。例として：

さらにINリレーションはパーティションキーの最後の列として、プライマリキーのフルセットで使うときにのみ有効である。
またCLUSTERING COLUMNをグループ化して使うこともできる。？

これはblog_titleとして"John's Blog"という値をもち、posted_atに'2012-01-01'が入った行を返す。blog_title > 'John''s Blog'としておけば、post_at <= '2012-01-01'という条件の行が返される。以下のクエリのようにはならない。

<order-by>
ORDER BYオプションはクエリ結果を順序付けするのに使う。列の名前を引数として取る。可能なオーダーは限られている（これはテーブルCLUSTERIG ORDERに依存している）。
・もしいかなるCLUSTERING ORDERの記載もないテーブルは、クラスタリングされた列とその逆順しか取れない。
・それでなければ、オーダーはCLUSTERING ORDERオプションどおりか、その逆順となる。
LIMIT
SELECTステートメントのLIMITオプションは結果として返す行の数を制限できる。
ALLOW FILTERING
デフォルトではCQLのSELECTクエリはフィルタリングを行わない。クエリは（生の）記録から（おそらく一部の）結果のセットを返す。フィルタをかけないクエリは決まった量の結果を返すため、実行時間が一定となる。

ALLOW FILTERINGオプションはクエリ結果のフィルタリングを行う。ALLOW FILTERINGは一握りのレコードを絞り出すためにクラスタにあるすべてのデータに検索をかけ、予期できないパフォーマンスコストを支払うことになる。
下記のテーブルはユーザーのプロフィール、生まれ年、国を保持している。

下記のクエリは通る。


なぜならどちらも、これらで返されるクエリに費やすパフォーマンスコストは一定だからである。もし1981年に生れたユーザがいないなら、二つ目のクエリはデータベースに保存されたユーザプロフィールの量に依存しなくなる（少なくとも直接は関係なくなる：なぜならセカンダリインデックスの実行を考えると、このクエリはクラスタ内でのノード数に依存し、保存されたデータ量には直接は依存しない。それでもノード数は常に保存されるデータ数より小さくなる）。もちろんどちらのクエリも多量の結果セットを返すかもしれないが、返されるデータの量は常にLIMITを使うことで制限をかけられる。

下記のクエリは通らない。

なぜならCassandraは多量のデータにスキャンをかけることはしないからである、たとえクエリに対する結果が少ないものであったとしても。たとえその中でフランス生まれが一握りであったとしても、1981年生まれでのユーザすべてをスキャンせねばならない。もしあなたが、あなたがなにをしようとしているか理解しているなら、ALLOW FILTERINGを末尾に付けることでクエリを実行できる。


Data Types
CQLは列の値として、コレクションを含む豊富な型をサポートしている。それらに加えて、ユーザはカスタムされた型も使用できる（JAVAのAbstractTypeを拡張したクラスで行われる）。シンタクスは以下のとおり：

ネイティブな型は大文字小文字を判別する。それらは予約語ではない。
下の表はデータ型と型のサポート値に関してである：

コレクションに関してもっと詳しい使い方は下のWorking with collectionsに示す。

Working with dates
timestamp型の値は64ビットのサイン付き整数で、ミリセカンドを表す。これはエポックにもとづいている：January 1 1970 at 00:00:00 GMT.
タイムスタンプはCQLでシンプルなlong整数で入力でき、先に示したエポックを基準としたミリセカンドで与えられる。
またISO8601のフォーマットで文字列で入力もでき、2011年3月2日午前4時5分GMTは下記の方法で記せる。

+0000はRFC822 4デジットタイムゾーン記法であり。+0000はGMTを示す。アメリカの太平洋側の標準時は-0800である。タイムゾーンは削除もでき、Cassandraノードは日付が基準点での値だと解釈する。

タイムゾーンを扱うことは難しく、タイムスタンプには常にタイムゾーンが表記されることが推奨される。？
もし日にちしか必要なければ下記のようにも書ける。

この場合、時間は表記されたかデフォルトのタイムゾーンで00:00:00と解釈される。

Couters
counter型はcounter columnを使うために定義する。カウンタ型となった列の値は64ビットの符号付整数で、二つの操作が可能である：インクリメントかデクリメントの（シンタクスはUPDATE参照）。カウンタの値をセットすることはできない。カウンタは最初のインクリメントかデクリメントをするまで存在せず、最初のそれを行うことによって前の値が0だったかのようにふるまう。カウンタの列を削除することはできるが、いくらかの制限がある（Cassandra Wikiを参照）。
カウンタ型を使うには以下の制限がある。
・PRIMARY KEYの一つとしては使えない。
・カウンタを含むテーブルはカウンタしか含めない。言い換えれば、PRIMARY KEY以外のすべての列がテーブルの外にあれば、それはカウンタを持てる。でなければカウンタは持てない。

Working with collections
Noteworthy characteristics
コレクションは非正規化された小さな関係性のあるデータを、保存するためにある。たとえば"ユーザの電話番号"や"メールにつけるラベル"のようなものを扱うのによい。ただ際限なくデータが増えるアイテム（"すべてのユーザへのメッセージ"や"センサによって引き起こされたイベント"）は適していないので、ふさわしいテーブルを使って保存するべきである。コレクションには下記の制限がある：
・コレクションは常にそれ全体を読み込む
・65535以上の要素を持つことはできない。正確に言えば65535個以上の要素に挿入はできるが、データを読めるのは最初の65535番目までである（CASSANDRA-5428参照）。
・setsとmapsへの挿入は内部で書き込み前に読み込みをし、listsでもいくらかの命令で同様のことをする（以下でlistのセクションを参照）。可能ならばlistsよりsetsを使うのが好ましい。
これらの制限は将来なくなるものがあるかもしれない。それでもコレクションのルールとして、非正規化された少量のデータの扱いを支えるものである。

Maps
mapはキーとバリューのペアがセットになったものである。マップは常にキーによってソートされ、その結果が返される。map型の列を作る場合、コンマ区切りでキーとバリューのペアを、角括弧<>であたえる。

mapの書き方はJSONのシンタクスと同様である。レコードをINSERTを使って書くとき、JSONのやり方で書けばいい。このやり方ではmapデータを丸々書き換えることに留意が必要。

mapへのキーバリューの追加、更新はUPDATEステートメントで行う。

TTLはINSERTにもUPDATEにも適用されるが、TTLは新しい挿入、更新によってセットされる値だけに有効である。例文で言い換える。

これはTTLを{ 'color' : 'green' }レコードのみに適用する。ほかのmap要素には影響しない。
mapレコードの削除は以下のように行う：

Sets
set型はユニークな値のコレクションである。セットはその値によってソートされる。set型の列を作るには、入れるデータの型を角括弧<>で囲う。

setデータを書くにはコンマ区切りで値を置いていき、丸括弧で囲う。INSERTを使うと丸々セットを置き換える。

値の追加および削除はUPDATEで、setでカラムを指定して行う。

mapsと同様、TTLは新しく挿入、更新される値に対してのみ有効である。

Lists
list型はユニークでない値の集合であり、順番が保持される。list型の列の値を作るには、listキーワードと共に角括弧で入れるデータの型を囲む。

以下で説明するように、リストにはいくらかの制限とパフォーマンスでの考慮点があり、可能ならばリストよりセットを使うべきである。
listデータはJSONスタイルのシンタクスで書ける。INSERTを使って書くならJSONでの配列と同じ書き方をする。INSERTを使うとリストを丸々置き換える。

値の追加（先頭か末尾への）は既存の列のlist要素への新しいJSONスタイルで記述する。

appendやprependはベキ等性の処理ではない。これはappendかprependでタイムアウトすると、安全にリトライは行われない（これでレコードのappendやprependを二回行うことになる）ということである。

リストは以下の命令もできる：位置を指定してのデータセット、および消去、与えられた値に一致する要素すべての削除など。しかしこれに反して他のコレクションと異なり、この三つの命令は更新前に読み込みをし、パフォーマンスを落とす。この命令は以下のシンタクスで記す。

mapsと同様、TTLは新しく挿入、更新された値に対してのみ有効である。

Functions
CQL3はいくらかのファンクションをサポートしている（今後も増える）。ファンクションは値に対してのみ有効で、個々の値を集約するようなファンクションはサポートしていない。サポートされているファンクションを以下に記す：
Token
tokenはファンクションは与えられたパーティションキーのトークンを計算する。トークンファンクションの正確な署名はクラスタに使われているテーブルと、そのパーティションに依存している。
tokenの引数の型はパーティションキーの列の値の型に依存する。返される型は使用しているパーティションに依存する：
・Murmur3Partitionerはbigint
・RandomPartitionerはvarint
・ByteOrderedPartitionerはblob
クラスタでデフォルトのMurmur3Partitionerを使い、以下のようにテーブルが定義されたとする。

このときtokenファンクションは一つのtext型の引数を取り（クラスタリングされた列はなく、パーティションキーはプライマリキーそのものである）、返される方はbigintである。

Timeuuid functions
now
nowファンクションは引数を取らず、新しいユニークなtimeuuidを作る（ステートメントが使われるときに実行される）。このメソッドは便利だが、WHEREにおいてセンスのない使われ方をする。

上記のクエリはなにも返さないだろう。返される値はユニークであることが保証されているのだから。

minTimeuuid and maxTimeuuid
minTimeuuid（あるいはmaxTimeuuid）ファンクションはtimestampの値t（タイムスタンプか日付の文字列）を取り、そこから適切なもっとも小さい（あるいはもっとも大きい）偽のtimeuuidを作る。

上のクエリでのtimeuuidの値tは‘2013-01-01 00:05+0000’より古く、‘2013-02-02 10:00+0000’より若くなる。t >= maxTimeuuid('2013-01-01 00:05+0000')は‘2013-01-01 00:05+0000’で作成されたtimeuuidを選択せず、本質的にはt > maxTimeuuid('2013-01-01 00:05+0000')と書くことと等価である。
注意：minTimeuuidとmaxTimeuuidによって作成された値を偽のUUIDと読んだ。なぜならそれらはRFC 4122で決められた時間ベースのUUID作成プロセスを順守していないためである。実際、これら二つのメソッドはユニークな値を返さない。よってこれらはクエリのためだけに使うべきである（例はこれまでのサンプルで示した）。この結果を挿入したりするのは悪いアイディアである。

dateOf and unixTimestampOf
dateOfファンクションとunixTimestampOfファンクションはtimeuuidを引数として取り、タイムスタンプを埋め込んだ出力を出す。だがdateOfファンクションはtimestamp型で値を返し、unixTimestampOfファンクションはbigint型で値を返す。

Blob conversion functions
いくらかのファンクションはネイティブな型をバイナリデータ（blob）に変換する。すべての<native-type>typeはCQL3（例外としてblob）によってサポートされ、typeAsBlobファンクションはtype型の引数を取り、blobとしてそれを返す。反対に、blobAsTypeファンクションは64ビットのblobを引数に取り、それをbigint値に変換する。よってbigintAsBlob(3)は0x0000000000000003であり、blobAsBigint(0x0000000000000003)は3である。


*****************************メモ
アトミック（原始性）　-　一つのトランザクションで行われる手続きが個々に分断されず、ひとまとまりとして扱われること。アトミックに実行されるといえば、トランザクション完遂に必要な手続きがすべて行われるかあるいは一つも行われないということになる。